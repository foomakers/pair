name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string
      publish:
        description: 'Set to "true" to run the publish-gh-packages job (gated)'
        required: false
        type: boolean
  release:
    types: [published]
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_no_v: ${{ steps.normalize_version.outputs.version_no_v }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '10.15.0'

      - name: Ensure pnpm is available (fallback)
        run: |
          if ! command -v pnpm >/dev/null 2>&1; then
            corepack enable || true
            corepack prepare pnpm@10.15.0 --activate || true
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Install Playwright browsers
        run: |
          pnpm --filter @pair/brand exec playwright install --with-deps chromium
          pnpm --filter @pair/website exec playwright install --with-deps chromium

      - name: Run quality checks
        run: pnpm quality-gate

      - name: Run E2E tests
        run: pnpm --filter @pair/website e2e

      - name: Build all packages
        run: pnpm build

      - name: Determine version
        id: version
        run: |
          chmod +x scripts/workflows/release/determine-version.sh
          ./scripts/workflows/release/determine-version.sh \
            --input-version "${{ github.event.inputs.version }}" \
            --release-tag "${{ github.event.release.tag_name }}" \
            --github-ref "$GITHUB_REF" \
            --output-file $GITHUB_OUTPUT \
            --env-file $GITHUB_ENV

      - name: Normalize version for filenames
        id: normalize_version
        run: |
          # Strip a leading 'v' from the version if present so filenames match scripts that expect no leading v
          RAW='${{ steps.version.outputs.version }}'
          # If RAW is empty (rare), fall back to github input/version
          if [ -z "$RAW" ]; then
            RAW='${{ github.event.inputs.version || github.event.release.tag_name || github.ref }}'
          fi
          # Remove leading 'v' or 'V'
          NORM=${RAW#v}
          NORM=${NORM#V}
          echo "version_no_v=$NORM" >> $GITHUB_OUTPUT

      - name: Create manual release artifacts
        run: |
          chmod +x scripts/workflows/release/package-manual.sh
          ./scripts/workflows/release/package-manual.sh ${{ steps.normalize_version.outputs.version_no_v }}

      - name: Create knowledge base dataset release artifact
        run: |
          chmod +x scripts/workflows/release/package-kb-dataset.sh
          ./scripts/workflows/release/package-kb-dataset.sh ${{ steps.normalize_version.outputs.version_no_v }}

      - name: Upload release artifacts as workflow artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pair-cli-manual-${{ steps.normalize_version.outputs.version_no_v }}
          path: |
            release/pair-cli-manual-${{ steps.normalize_version.outputs.version_no_v }}.zip
            release/pair-cli-manual-${{ steps.normalize_version.outputs.version_no_v }}.zip.sha256
          retention-days: 30

      - name: Upload knowledge base dataset artifact
        uses: actions/upload-artifact@v4
        with:
          name: knowledge-base-dataset-${{ steps.normalize_version.outputs.version_no_v }}
          path: |
            release/knowledge-base-${{ steps.normalize_version.outputs.version_no_v }}.zip
            release/knowledge-base-${{ steps.normalize_version.outputs.version_no_v }}.zip.sha256
          retention-days: 30

      - name: Create registry TGZ from manual release folder
        run: |
          chmod +x scripts/workflows/release/create-registry-tgz.sh
          ./scripts/workflows/release/create-registry-tgz.sh ${{ steps.normalize_version.outputs.version_no_v }} release/pair-cli-manual-${{ steps.normalize_version.outputs.version_no_v }}.zip

      - name: Upload TGZ artifact as workflow artifact
        uses: actions/upload-artifact@v4
        with:
          name: pair-cli-tgz-${{ steps.normalize_version.outputs.version_no_v }}
          path: |
            release/pair-cli-${{ steps.normalize_version.outputs.version_no_v }}.tgz
            release/pair-cli-${{ steps.normalize_version.outputs.version_no_v }}.tgz.sha256
            release/pair-cli-${{ steps.normalize_version.outputs.version_no_v }}.meta.json
          retention-days: 30

      - name: Smoke-test manual ZIP artifact (verify checksum, run --version, run pair install)
        env:
          PAIR_DIAG: '1'
        run: |
          chmod +x scripts/workflows/release/smoke-test-manual-artifact.sh
          ./scripts/workflows/release/smoke-test-manual-artifact.sh ${{ steps.normalize_version.outputs.version_no_v }}

      - name: Smoke-test npm TGZ artifact (verify checksum, install into sample-project, run --version, run pair install)
        env:
          PAIR_DIAG: '1'
        run: |
          chmod +x scripts/workflows/release/smoke-test-npm-artifact.sh
          ./scripts/workflows/release/smoke-test-npm-artifact.sh ${{ steps.normalize_version.outputs.version_no_v }}

      - name: Create GitHub Release and upload assets
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.version != ''
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          chmod +x scripts/workflows/release/create-github-release.sh
          ./scripts/workflows/release/create-github-release.sh ${{ steps.version.outputs.version }} ${{ github.token }}

  deploy-website:
    runs-on: ubuntu-latest
    needs: release
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '10.15.0'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # Vercel CLI rejects deploys when the commit author email is not in the
      # Vercel account's verified emails. Amend locally (never pushed) to set
      # the org email so the deploy succeeds.
      - name: Set git author for Vercel
        run: |
          git config user.email "foomakers42@gmail.com"
          git config user.name "foomakers"
          git commit --amend --no-edit --reset-author --no-verify

      - name: Deploy to Vercel (production)
        run: |
          chmod +x scripts/workflows/release/deploy-website.sh
          ./scripts/workflows/release/deploy-website.sh --prod
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  publish-gh-packages:
    runs-on: ubuntu-latest
    needs: release
    permissions:
      contents: read
      packages: write
    env:
      # Use the workflow-provided token if available; consumers can also set a repository secret
      # Publishing requires write:packages scope. GITHUB_TOKEN is sufficient for public repos.
      GITHUB_TOKEN: ${{ github.token }}
      NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    # Run this job for manual dispatch with publish=true OR when a tag push starting with v* occurs
    if: >
      (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'true')
      || (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))
    steps:
      - name: Publish gate check
        # Decide at runtime if we should actually publish. If this run was a manual workflow_dispatch
        # require inputs.publish == 'true'; for push/tag events skip the gate and proceed.
        run: |
          set -euo pipefail
          INP_EVENT='${{ github.event_name }}'
          if [ "$INP_EVENT" = "workflow_dispatch" ]; then
            INP_PUBLISH='${{ github.event.inputs.publish }}'
            if [ "$INP_PUBLISH" != "true" ]; then
              echo "Publish not requested (inputs.publish != true). Exiting job without publishing."
              exit 0
            fi
          fi
          echo "Publish requested or triggered by tag push; continuing with publish job."
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '10.15.0'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Download TGZ artifact
        uses: actions/download-artifact@v4
        with:
          # Prefer normalized version (no leading v) exposed by the release job
          name: pair-cli-tgz-${{ needs.release.outputs.version_no_v || needs.release.outputs.version || steps.version.outputs.version }}

      - name: Validate package metadata and token
        run: |
          set -euo pipefail
          V=${{ needs.release.outputs.version_no_v || needs.release.outputs.version || steps.version.outputs.version || github.event.inputs.version }}
          TGZ=pair-cli-${V}.tgz
          echo "Looking for expected files: $TGZ and pair-cli-<version>.meta.json in workspace:" && ls -la || true
          if [ ! -f "$TGZ" ]; then
            echo "Warning: expected tarball $TGZ not found. Listing available .tgz files:" && ls -la *.tgz 2>/dev/null || true
            # Continue: attempt to locate a .tgz produced by the artifact bundle
          fi
          # Prefer reading package metadata produced at pack time (meta.json) inside the artifact
          META_FILE=pair-cli-${V}.meta.json
          if [ ! -f "$META_FILE" ]; then
            ALT_META=$(ls pair-cli-*.meta.json 2>/dev/null | head -n1 || true)
            if [ -n "$ALT_META" ]; then
              echo "Info: exact META_FILE $META_FILE not found; using discovered meta file: $ALT_META"
              META_FILE="$ALT_META"
            else
              echo "Info: no pair-cli-*.meta.json found in workspace; will fall back to workspace package.json (diagnostics below)"
            fi
          fi
          if [ -n "${META_FILE:-}" ] && [ -f "$META_FILE" ]; then
            PKG_NAME=$(node -e "console.log(JSON.parse(require('fs').readFileSync('$META_FILE','utf8')).name)")
            PKG_PRIVATE=$(node -e "console.log(JSON.parse(require('fs').readFileSync('$META_FILE','utf8')).private)")
            echo "Found package metadata file: $META_FILE"
          else
            # Fallback to workspace package.json for validation
            echo "Falling back to workspace package.json for validation"
            PKG_NAME=$(node -e "console.log(require('./apps/pair-cli/package.json').name)")
            PKG_PRIVATE=$(node -e "console.log(require('./apps/pair-cli/package.json').private)")
          fi
          echo "Found package: $PKG_NAME (private=$PKG_PRIVATE)"
          if [ "$PKG_PRIVATE" = "true" ] || [ "$PKG_PRIVATE" = "1" ]; then
            echo "Aborting publish: package.private is true"
            exit 1
          fi
          if [[ "$PKG_NAME" != @foomakers/* ]]; then
            echo "Aborting publish: package.name must be scoped to @foomakers for GitHub Packages publishing. Found: $PKG_NAME"
            exit 1
          fi
          # Prefer job-provided GITHUB_TOKEN; if not present, check repository secrets.GITHUB_TOKEN
          # For public repos, GITHUB_TOKEN has sufficient permissions for publishing.
          if [ -z "${GITHUB_TOKEN:-}" ] && [ -z "${NODE_AUTH_TOKEN:-}" ]; then
            echo "Warning: No GITHUB_TOKEN/NODE_AUTH_TOKEN available in this run."
            echo "If you intended to publish, re-run with the 'publish' input (workflow_dispatch) and ensure the GITHUB_TOKEN secret is configured for the repository or use a personal token in secrets.GITHUB_TOKEN."
            echo "Aborting publish to avoid accidental public package publication." 
            exit 1
          fi
          echo "Token availability: GITHUB_TOKEN=${GITHUB_TOKEN:+present} NODE_AUTH_TOKEN=${NODE_AUTH_TOKEN:+present}"

      - name: Publish to GitHub Packages
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          V=${{ needs.release.outputs.version_no_v || needs.release.outputs.version || steps.version.outputs.version || github.event.inputs.version }}
          TGZ=pair-cli-${V}.tgz
          echo "Publishing $TGZ to GitHub Packages"
          # If NODE_AUTH_TOKEN isn't set explicitly, fall back to job-provided GITHUB_TOKEN
          if [ -z "${NODE_AUTH_TOKEN:-}" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
            NODE_AUTH_TOKEN="$GITHUB_TOKEN"
          fi

          # Configure npm auth for GitHub Packages; write to $HOME/.npmrc so npm always finds it
          if [ -n "${NODE_AUTH_TOKEN:-}" ]; then
            printf "@foomakers:registry=https://npm.pkg.github.com/\n//npm.pkg.github.com/:_authToken=${NODE_AUTH_TOKEN}\nalways-auth=true\n" > "$HOME/.npmrc"
            chmod 600 "$HOME/.npmrc"
            echo "Wrote npm auth to $HOME/.npmrc"
          else
            echo "No NODE_AUTH_TOKEN available; npm publish may fail due to missing credentials"
          fi

          npm publish "$TGZ" --registry https://npm.pkg.github.com/
          echo "Published. Verifying via npm view..."
          sleep 3
          # Determine package name from meta file if present (artifact produced it at pack time)
          if [ -f "pair-cli-${V}.meta.json" ]; then
            PKG_PUB_NAME=$(node -e "console.log(JSON.parse(require('fs').readFileSync('pair-cli-${V}.meta.json','utf8')).name)")
          else
            PKG_PUB_NAME=$(node -e "console.log(require('./apps/pair-cli/package.json').name)")
          fi
          echo "Verifying published package: $PKG_PUB_NAME"
          npm view "$PKG_PUB_NAME" version --registry https://npm.pkg.github.com/ || true
