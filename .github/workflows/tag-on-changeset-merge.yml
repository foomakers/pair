name: Tag on Changeset PR Merge

on:
  pull_request_target:
    types: [closed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to simulate'
        required: true
        type: string
      merge_commit_sha:
        description: 'Merge commit SHA'
        required: true
        type: string
      head_ref:
        description: 'Head ref (should start with changeset-release/)'
        required: true
        type: string

jobs:
  tag:
    # Only run when the PR was merged and it is a changeset-release branch, or when manually triggered
    if: (github.event.pull_request.merged == true && startsWith(github.event.pull_request.head.ref, 'changeset-release/')) || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Set event data for manual trigger
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "PR_NUMBER=${{ github.event.inputs.pr_number }}" >> $GITHUB_ENV
          echo "MERGE_COMMIT_SHA=${{ github.event.inputs.merge_commit_sha }}" >> $GITHUB_ENV
          echo "HEAD_REF=${{ github.event.inputs.head_ref }}" >> $GITHUB_ENV
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use the workflow's token (GITHUB_TOKEN) which has minimal permissions
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Diagnostic - print GITHUB_TOKEN repo permissions
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            core.info(`Repository: ${context.repo.owner}/${context.repo.repo}`)
            try {
              const repo = await github.repos.get({ owner: context.repo.owner, repo: context.repo.repo })
              core.info(`Effective permissions for token: ${JSON.stringify(repo.data.permissions)}`)
            } catch (err) {
              core.warning(`Could not fetch repo permissions: ${err.message}`)
            }

      - name: Debug PR information
        run: |
          echo "PR Number: ${{ env.PR_NUMBER || github.event.pull_request.number }}"
          echo "PR Head Ref: ${{ env.HEAD_REF || github.event.pull_request.head.ref }}"
          echo "PR Base Ref: ${{ github.event.pull_request.base_ref }}"
          echo "PR Merged: ${{ github.event.pull_request.merged }}"
          echo "Merge Commit SHA: ${{ env.MERGE_COMMIT_SHA || github.event.pull_request.merge_commit_sha }}"
          echo "Head ref starts with changeset-release/: ${{ startsWith(env.HEAD_REF || github.event.pull_request.head.ref, 'changeset-release/') }}"

      - name: Determine merge commit
        id: merge
        run: |
          echo "merge_sha=${{ env.MERGE_COMMIT_SHA || github.event.pull_request.merge_commit_sha }}" >> $GITHUB_OUTPUT

      - name: Determine monorepo version (highest bumped package)
        id: determine_version
        run: |
          set -euo pipefail
          sha="${{ steps.merge.outputs.merge_sha }}"
          # Collect changed package.json files from the merge commit
          files=$(git show --name-only --pretty="" "$sha" | grep -E '(^|/)(package.json)$' || true)
          if [ -z "$files" ]; then
            echo "No package.json changed in merge commit; exiting."
            exit 0
          fi
          echo "Changed package.json files:" >&2
          echo "$files" >&2
          versions=""
          for f in $files; do
            # Ensure file exists in repo (it should in merge commit)
            if [ ! -f "$f" ]; then
              # try extracting file from commit
              # Extract version using node to avoid jq dependency
              tmpver=$(git show "$sha":"$f" 2>/dev/null | node -e "let s=''; process.stdin.on('data',c=>s+=c); process.stdin.on('end',()=>{try{const p=JSON.parse(s); console.log(p.version||'')}catch(e){}})")
            else
              tmpver=$(node -e "try{const p=require('./$f'); console.log(p.version||'')}catch(e){}" 2>/dev/null || echo)
            fi
            if [ -n "$tmpver" ] && [ "$tmpver" != "null" ]; then
              echo "$tmpver"
              versions="$versions $tmpver"
            fi
          done
          # pick highest semver (sort -V works for semver on ubuntu)
          # sanitize versions list and pick last
          v=$(echo "$versions" | sed '/^$/d' | sort -V | tail -n1 || true)
          if [ -z "$v" ]; then
            echo "Could not determine a version from changed package.json files; exiting." >&2
            exit 0
          fi
          echo "version=$v" >> $GITHUB_OUTPUT
          echo "VERSION=$v" >> $GITHUB_ENV

      - name: Create monorepo tag via REST API
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo
            const sha = '${{ steps.merge.outputs.merge_sha }}'

            // Try to read package.json from the merge commit
            let ver = null
            try {
              const content = await github.repos.getContent({ owner, repo, path: 'apps/pair-cli/package.json', ref: sha })
              const buf = Buffer.from(content.data.content, content.data.encoding)
              const pkg = JSON.parse(buf.toString())
              ver = pkg.version
              core.info(`Version from pair-cli package.json: ${ver}`)
            } catch (err) {
              core.warning(`Could not read package.json from merge commit: ${err.message}`)
            }

            if (!ver) {
              core.info('Could not determine version from merge commit; skipping tag creation')
              return
            }

            const tag = `v${ver}`

            // Check if tag exists
            try {
              await github.git.getRef({ owner, repo, ref: `tags/${tag}` })
              core.info(`Tag ${tag} already exists, skipping`)
              return
            } catch (err) {
              if (err.status !== 404) throw err
            }

            // Create a tag object and reference with retries
            const maxAttemptsTag = 3
            for (let attempt = 1; attempt <= maxAttemptsTag; attempt++) {
              try {
                const tagObj = await github.git.createTag({
                  owner,
                  repo,
                  tag,
                  message: `Release ${tag} (from changeset PR #${{ env.PR_NUMBER || github.event.pull_request.number }})`,
                  object: sha,
                  type: 'commit'
                })

                await github.git.createRef({
                  owner,
                  repo,
                  ref: `refs/tags/${tag}`,
                  sha: tagObj.data.sha
                })

                core.info(`âœ… Created tag ${tag}`)
                break
              } catch (err) {
                core.warning(`Attempt ${attempt} failed to create tag: ${err.message}`)
                if (attempt === maxAttemptsTag) throw err
                const delay = 3000 * attempt
                core.info(`Retrying after ${delay}ms...`)
                await new Promise(r => setTimeout(r, delay))
              }
            }
